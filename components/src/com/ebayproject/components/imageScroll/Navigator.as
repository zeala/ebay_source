package com.ebayproject.components.imageScroll {		import com.ebayproject.events.ItemEvent;	import com.ebayproject.events.PopupEvent;		import flash.display.DisplayObject;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.utils.Timer;		import mx.collections.ArrayCollection;	import mx.core.UIComponent;
	[Event(name="addPopup", type="com.ebayproject.events.PopupEvent")]	[Event(name="removePopup", type="com.ebayproject.events.PopupEvent")]		public class Navigator extends UIComponent{		private var _navArray	:Array = [];		private var clip		:NavItemMXML;		private var _damping	:Number		= 10;		private var _centerX	:Number		= 200;		private var totalWidth	:Number		= 0;		private var _containerWidth:Number = 0;		private var _itemWidth:Number = 0;		private var timer:Timer;		private var currentSlide:int = 0;		private var _slideDelaySeconds:Number = 3;		private var slideShowOn : Boolean = false;					private var _searchItems : ArrayCollection;		[Bindable("searchItemsChange")]		public function get searchItems():ArrayCollection		{			return _searchItems;		}		public function set searchItems(val:ArrayCollection):void		{			_searchItems = val;			populateNavigator();			dispatchEvent( new Event("searchItemsChange"));		}				public function Navigator(			)		{			super();		}				private function populateNavigator():void		{			var count:int = 0;						this.removeChildren();						for each ( var imgSource : String in searchItems )			{				var navItem : NavItemMXML = new NavItemMXML();				navItem.index = count;				navItem.searchItem = searchItems[count];				navItem.addEventListener( NavItemMXML.EVENT_CLICKED, centerNav );				navItem.addEventListener(					MouseEvent.MOUSE_OVER, itemMouseOverHandler, false, 0, true);				navItem.addEventListener(					MouseEvent.MOUSE_OUT, itemMouseOutHandler, false, 0 ,true );				navItem.addEventListener(					ItemEvent.VIEW_ITEM_ON_EBAY, viewItemHandler, false, 0 , true );				addChild( navItem );				_navArray.push( navItem );				totalWidth += navItem.width;				count ++;			}									if( slideShowOn )			{				startSlideshow( )					}			//select the first image			_navArray[0].dispatchEvent( new Event( NavItemMXML.EVENT_CLICKED ) );			swap();		}						private function viewItemHandler( event : ItemEvent ) : void		{					}				private function itemMouseOverHandler(event:MouseEvent):void		{			if ( ! (event.currentTarget is NavItemMXML ) ) return 						var e : PopupEvent = new PopupEvent(				PopupEvent.ADD_POPUP, event.currentTarget as DisplayObject );			dispatchEvent( e );		}				private function itemMouseOutHandler(event:MouseEvent):void		{			var e : PopupEvent = new PopupEvent(				PopupEvent.REMOVE_POPUP, event.currentTarget as DisplayObject );			dispatchEvent( e ) ;		}						public function startSlideshow( ):void		{ 			timer = new Timer( _slideDelaySeconds * 1000 ) 			timer.addEventListener( TimerEvent.TIMER, onTimer ); 			 			timer.start();						}				/**		 * Stop the slideshow		 * 		 */				public function stopSlideshow( ):void		{			timer.removeEventListener( TimerEvent.TIMER, onTimer );			timer.stop();		}				/**		 * "Click" the next image in the sequence. Currently these clicks are odd		 * because it is neccesary to figure out exactly which item needs to be clicked		 * based on its position in the container relative to the center, currently selected item.		 *  		 * @param te		 * @private		 */				private function onTimer( te:TimerEvent ):void		{			for( var i:int=0;i<this.navArray.length;i++)			{				var navItem:NavItemMXML = navArray[i];				trace( navItem.index, clip.index );				if( clip.index == navArray.length - 1 )				{					if( navItem.index == 0 )					{						_navArray[i].dispatchEvent( new Event( NavItemMXML.EVENT_CLICKED ) );						return					}				}				if( navItem.index == clip. index +1 )				{					_navArray[i].dispatchEvent( new Event( NavItemMXML.EVENT_CLICKED ) );					return;				}			}		}				/**		 * Shifts the images to keep the continuous scroll continuous		 * @private		 */				private function swap():void {			aligned();						var left:NavItemMXML = _navArray[0];			var right:NavItemMXML = _navArray[_navArray.length-1];						for (var i:int = 0; i<_navArray.length; i++) {				if (left.x<0-left.width) {					// moves clips from first to last					_navArray.push(_navArray.shift());					left.x = right.x+right.width;				}				                       				if (right.x>totalWidth-right.width) {					// moves clips from last to first					_navArray.unshift(_navArray.pop());					right.x = left.x-right.width;				}			}		}				/**		 * Moves the selected NavItem to the center of the navigation container. 		 * @param e		 * @private		 */				private function centerNav(e:Event):void 		{			//if( timer ) stopSlideshow();						removeEventListener(Event.ENTER_FRAME, setPositions);							clip = e.target as NavItemMXML;			trace(clip.index)			for (var i:int = 0; i<_navArray.length; i++) {				if(navArray[i]!=clip){					navArray[i].enable();				} else navArray[i].disable();			}			addEventListener(Event.ENTER_FRAME, setPositions);		}				/**		 * Set the positions of the NavItems 		 * @param e		 * @private		 */				private function setPositions(e:Event = null):void {			var thisX	:Number	= clip.x+clip.width;			var deltaX	:Number	= thisX-(_centerX + clip.width / 2 );			_navArray[0].x -= deltaX/_damping;			swap();						if (Math.abs(deltaX)<1) {				removeEventListener(Event.ENTER_FRAME, setPositions);				}		}		/**		 * Make sure all of the NavItems stay aligned while they are swapped 		 * @private		 */				private function aligned():void {			for (var i:int = 1; i<_navArray.length; i++) {				_navArray[i].x = _navArray[i-1].x+_navArray[i-1].width;			}		}				/**		 * An array of NavItems		 * @return 		 * 		 */				public function get navArray():Array { return _navArray; }			}	}